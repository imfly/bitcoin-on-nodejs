进行中...

# 区块链

## 前言

比特币诞生以来，经过7个年头的发展，加密货币从小众的玩具，到世界各国的围追堵截，再到今天各大公司的参与和追捧，其中最令各国恐惧阻挠的原因是区块链，最令人神往的也是因为区块链。同样，为什么要写这本书，为什么要把版权保护和知识分享建立去中心化的架构之上，原因还是区块链。

我们分享的源码项目——亿书，是一款加密货币产品，用时髦的话说，更是一款实用的区块链产品。那么，区块链是什么？有那些非比寻常的特点？这一章，我们就来详细解释和说明，并把亿书相关的代码逻辑，认真阅读和理解，以便更加深入的了解和掌握这项技术。

## 源码

blocks.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/blocks.js

block.js https://github.com/Ebookcoin/ebookcoin/blob/logic/block.js

loader.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/loader.js

## 类图

![blocks-class.png][]

## 流程图

![blocks-activity.png][]

## 解读

#### 1.区块链是什么？

区块链是去中心化的公开账本，由包含交易信息的区块从后向前有序链接起来的数据结构，可以存储成文件形式，不过多数产品存储在一个数据库中，比如比特币使用Google的LevelDB数据库存储。

（1）从数据库设计角度理解区块链

用数据库的概念理解，区块链就是一张“自引用”的数据库表。每条记录代表一个区块，这条记录（区块）记录着它前面（时间上）一条记录的信息，可以直接查询到前一条记录，因此从任何一条记录开始都可以往前顺序追溯，直到第一条记录。普通自引用表结构，通常使用ID作为关联外键，加密货币使用的是经过加密处理的信息字段，称为区块头信息，通常包含更多信息。

与区块链直接关联的另一张重要的表，就是交易表。加密货币包含大量的交易，交易记录通常保存在一张独立表里，并与区块链形成多对一的关联方式。如此以来，只要追溯到区块，就很容易查询到该区块包含的交易记录。

（2）形象化理解区块链

人们通常把具有先后顺序的数据结构，使用栈来表示，比特币白皮书把这种结构进一步形象化，第一个区块作为栈底，然后其他区块按照时间顺序依次堆叠在上面，这样一来，区块与首区块之间的距离就表示“高度”，“顶端”就表示最新添加的区块。每个区块包含大量交易，就是包含在对应栈里的数据。这么以来，我们可以把区块链想象成下面这样：

![stack-drawers.png][]

#### 2.区块链的特点

我们可以按照堆栈的方式理解数据结构，并采用自引用的关联方式设计数据库模型，但是做到这些，我个人认为并不代表就是区块链了，它还必须被置于去中心化的网络，由不分布式网络节点共同维护，才能称得上区块链。当然，也有人持不同观点，他们认为一个中心化的应用，如果使用类似的数据结构，会更加安全，同时因为避免了分叉，性能或许更高，但我认为没有了分布式网络的支撑，这点改进算不上什么。

因此，区块链除了上述数据结构特点，还必须被置于分布式网络之中。由于处在分布式网络，每个节点地位和权限相同，物理世界情况复杂，网络同步的时间先后是无法预测的，必然会导致区块链分叉的出现，这与什么样的共识机制没有直接关系，不论是采取工作量证明机制（PoW)的比特币、还是采取股权证明机制（PoS）的点点币，亦或是这里采取授权股权证明机制（DPoS）的亿书币，都是如此。当然，DPoS机制对节点总量有限制，分叉的时间可能相对短一些。

汇总一下，区块链具备这样的特点：

* 分布存储：区块链处于分布式网络之中，无论什么公链、私链，还是联盟链，都要采取分布式存储，使用一种机制保证区块链的同步和统一;
* 公开透明：每个节点都有一个数据库副本，数据可以任意查询;
* 无法篡改：每一区块都会记录前一区块的加密区块头信息，并实现追溯和验证，确保无法篡改;
* 存在分叉：这是分布式网络决定的。

也正是因为这样的特点（特别是前三个），区块链的概念才逐渐火爆起来。因为可以解决很多中心化应用无法解决的问题，特别是对于银行业而言，电子支付、资金结算、审计等等，成本会大幅度降低。而亿书，就是利用它公开透明、可追溯的特点，与数字出版结合起来，彻底解决当前数字出版版权保护不力的顽疾。

#### 3.亿书区块链数据库设计

与区块链相关的数据库结构如图：

![blocks-database.png][]

#### 4.区块头信息处理

产生c结尾的地址：

```
// logic/block.js 20行
private.getAddressByPublicKey = function (publicKey) {
	var publicKeyHash = crypto.createHash('sha256').update(publicKey, 'hex').digest();
	var temp = new Buffer(8);
	for (var i = 0; i < 8; i++) {
		temp[i] = publicKeyHash[7 - i];
	}

	var address = bignum.fromBuffer(temp).toString() + "C";
	return address;
}

// 上面的方法，在312行dbRead函数里调用，
generatorId: private.getAddressByPublicKey(raw.b_generatorPublicKey),
```

## 总结

## 链接

## 参考

[从数据库发展规律看区块链技术](http://chainb.com/?P=Cont&id=33)
[http://www.8btc.com/what-is-blockchain](http://www.8btc.com/what-is-blockchain)
[区块链的运行原理和发展](http://www.8btc.com/blockchain-principle)

[blocks-class.png]: ../styles/images/modules/blocks/blocks-class.png
[blocks-activity.png]: ../styles/images/modules/blocks/blocks-activity.png
[stack-drawers]: ../styles/images/third/drawers.png
[blocks-database.png]: ../styles/images/modules/blocks/blocks-database.png
