进行中...

# 区块链

## 前言

比特币诞生以来，经过7个年头的发展，加密货币从小众的玩具，到世界各国的围追堵截，再到今天各大公司的参与和追捧，其中最令各国恐惧阻挠的原因是区块链，最令人神往的也是因为区块链。同样，为什么要写这本书，为什么要把版权保护和知识分享建立去中心化的架构之上，原因还是区块链。

我们分享的源码项目——亿书，是一款加密货币产品，用时髦的话说，更是一款实用的区块链产品。那么，区块链是什么？有那些非比寻常的特点？这一章，我们就来详细解释和说明，并把亿书相关的代码逻辑，认真阅读和理解，以便更加深入的了解和掌握这项技术。

## 源码

blocks.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/blocks.js

block.js https://github.com/Ebookcoin/ebookcoin/blob/logic/block.js

loader.js https://github.com/Ebookcoin/ebookcoin/blob/v0.1.3/modules/loader.js

## 类图

![blocks-class.png][]

## 流程图

![blocks-activity.png][]

## 解读

#### 1.区块链是什么？

区块链是去中心化的公共账本，是一种由包含交易信息的记录从后向前有序链接起来的数据结构，可以存储成文件形式，不过多数产品存储在一个数据库中，比如比特币使用Google的LevelDB数据库存储。

（1）从数据库设计角度理解区块链

用数据库的概念理解，区块链就是一张“自引用”的数据库表。每条记录代表一个区块，这条记录（区块）记录着它前面（时间上）一条记录的信息，可以直接查询到前一条记录，因此从任何一条记录开始都可以往前顺序追溯，直到第一条记录。普通自引用表结构，通常使用ID作为关联外键，加密货币使用的是经过加密处理的信息字段，称为区块头信息，具有签名认证作用，可实现自我验证，防止被篡改。

与区块链直接关联的另一张重要的表，就是交易表。加密货币包含大量的交易，我们之前分析过，交易可以是加密货币，也可以是债权、股权或版权等各类数字资产，这些交易保存在一张独立表里，并与区块链形成多对一的关联方式。如此以来，只要追溯到区块，就很容易查询到该区块包含的交易记录。这样一个公开透明、无法篡改、方便追溯的账本就形成了。

上面是从数据库查询的角度，也就是读数据角度考虑的，如果从写入的角度思考，就更有意思了。写入是要根据需求不同进行不同的编码，我们前面说过，加密货币的各种功能都可以通过扩展交易类型进行编码，如果把一些现实中的合同规则进行编码，要求系统在某个条件下自动执行（写入或更新）某交易，自然也是件简单轻松的事情，这就是“智能合约”的简单理解。

我们在第一部分提到过“智能合约”的概念，在这里再次提及，作为程序员能够更加直观的去理解编码上的可行性。“智能合约”也是目前加密货币社区讨论火热的概念，绝不仅仅是这里提到的简单的概念，可以发挥你想象的翅膀，从加密货币扩展到现实世界的各种场景，比如：自动贩卖机、销售终端、大公司间的电子数据交换和银行间用于转移和清算的支付网络，以及音乐、电影和电子书等数字版权交易等。

（2）形象化理解区块链

人们通常把具有先后顺序的数据结构，使用栈来表示，比特币白皮书把这种结构进一步形象化，第一个区块作为栈底，然后其他区块按照时间顺序依次堆叠在上面，这样一来，区块与首区块之间的距离就表示“高度”，“顶端”就表示最新添加的区块。每个区块包含大量交易，就是包含在对应栈里的数据。于是，一个区块链就象下面这样：

![stack-drawers.png][]

这里，区块链就像一个大大的橱柜，区块就是其中一个抽屉，每个抽屉里是满满的交易。

（3）区块链分叉

**物理分叉**。每一个区块都与它的前一区块（父区块）关联，而对它后面的区块（子区块）无限制，也就是说最顶端的区块，肯定知道它的父区块（已经写入区块链），但不知道子区块（或许还没有产生，也可能在传输的过程中）。我们知道，从物理层面，数据库、硬盘、网络的IO操作是最耗费时间成本的，在某一个时刻，多个最新区块同时找到父区块是很常见的现象，这就必然导致区块链分叉（从主链向多个方向发展）。这种情况，是在同一个软件版本的情况下，没有人为干预，不妨叫做物理分叉。

显然，物理分叉取决于物理环境，这与什么样的共识机制没有直接关系，不论是采取工作量证明机制（PoW)的比特币、还是采取股权证明机制（PoS）的点点币，亦或是这里采取授权股权证明机制（DPoS）的亿书币，都是如此。为了保持区块链的单一链条，解决分叉的最简单方式就是放任每个分叉继续增长，通常在下一刻就会出现差别，这时候软件选择最长的那个链条作为主链即可。在具体的设计开发过程中，这也是一个逻辑相对复杂的难点。

**人为分叉**。那么，如果存在人的干预，会怎么样呢？我们知道，世界上没有绝对完美无缺的东西，人类开发设计的软件也不例外。而且，人类的需求是在变化的，软件要不断推出新功能来应对，不然早晚会被用户抛弃。所以，软件出现漏洞，或者添加新的功能，这类情况是再正常不过的事情。看看微软的windows系统，时不时跳出来的漏洞修复提醒就知道这类事情多么常见。这时候，旧版本的软件对新版本软件产生的区块可能出现兼容性问题，甚至需要人为改变区块链的走向，这就导致分叉行为，不妨叫做人为分叉。

很显然，人为分叉也是无法避免的事情。你可能认为很简单，有漏洞就修复吧，有新功能加上就得了，有什么好解释的。事实上，加密货币核心是交易，是价值转移的手段，规则的改变直接关系到所有持币人的利益。我们在第一部分说过，人是趋利的，要追求利益最大化，新功能能否保护用户的利益，还是代表了少部分利益集团的意志，应该如何约束和决策，这已经不单单是一个技术问题，更多的是政治问题，需要社区共同参与。历史证明，承载了较大资金盘的加密货币，在某一次分叉过程中，个别用户或矿工没有及时更新软件，就造成了直接经济损失。所以，每一个持币用户都非常关心任何一次分叉行为，如果需要，都有可能站出来表达自己的意愿。

**硬分叉和软分叉**。它们都属于人为分叉，孰优孰劣也是当前社区分歧比较严重的问题。最初，社区区分这两个概念的简单方法就是，“硬分叉”是与旧版本的兼容度不高，但是获得了社区共识的规则明确的分叉行为，“软分叉”恰恰相反。发展到今天，只要是明确的“分叉”行为，大家都会寻求社区共识，所以二者的区别主要集中在软件兼容问题上了。这里的社区共识，是指包括软件开发者、矿工和使用者在内的整个软件社区，采取投票等方式，获得最大程度的一致性意见，通常是90%以上的社区成员同意就认为是达成了社区共识。比如最近以太坊为了应对The Dao遭受黑客攻击而实施的紧急硬分叉，就获得了社区87%的同意（接近90%）。

从技术角度讲，这里所谓的“硬”，主要体现在与旧版本的不兼容（或少量兼容）上，属于抛弃旧版本的行为，如果用户不升级软件，一定会带来直接损失，感觉上更加强硬得多。“软分叉”，最大程度的保持了对以前版本的兼容性，做得好的话，多个版本可以同时运行，类似于正常的版本迭代升级，用户可以自由选择是否升级。有人说“硬分叉”是很糟糕的事情，另一些人认为“软分叉”风险更大。从历史来看，比特币经历过很多次“硬分叉”和“软分叉”，依然安全和坚挺。事实证明，只要准备充分，操作得当，无论是“硬分叉”，还是“软分叉”，都不可怕，只不过“软分叉”在编码中需要考虑的情况更加复杂，出现Bug的可能性更高，对用户的影响较为隐蔽，风险反而更大一些。

我个人不喜欢谈政治，但是作为交易媒介的新兴产物——加密货币，天生就是政治的附属品，各种法币大家不会怀疑，比特币和各种竞争币也是如此。这些货币的持续发展，往往是不同利益团体（至少包括开发者、矿工和用户）之间不断博弈的结果。最初是开发者主导，某个时期矿工的力量更加强大，后期用户的力量就不容忽视。也正是这些力量之间的制衡，才让加密货币相对持续稳健的发展，当这三种力量达到均衡的时候，就是这个加密货币相对成熟的时候。最近，以太坊硬分叉成功处理Dao遭受的黑客攻击事件，搅动了整个加密货币社区，不同利益者发出不同的声音，这是好事，充分说明加密货币仍处在初级阶段，还有很长的路要走。

#### 2.区块链的特点

我们可以按照堆栈的方式理解数据结构，并采用自引用的关联方式设计数据库模型，但是做到这些，我个人认为并不代表就是区块链了，它还必须被置于去中心化的网络，由P2P网络节点共同维护，才能称得上区块链。当然，也有人持不同观点，他们认为一个中心化的应用，如果使用类似的数据结构，会更加安全（比不使用该结构的中心化系统），同时可以避免分叉，性能或许更高（比去中心化的系统），但事实上没有了P2P网络的支撑，这点改进算不上什么。我们之前分析过，P2P网络本身就是一条非常好的安全屏障，单点被攻击或被破解，对整个网络系统没有太大伤害，而任何中心化的系统仅仅相当于单节点，安全性大大降低。所以，为了那些许的性能改进，却要牺牲更好的安全性，有点得不偿失。

汇总以上信息，区块链应该具备这样几个特点：

* 分布存储：区块链处于P2P网络之中，无论什么公链、私链，还是联盟链，都要采取分布式存储，使用一种机制保证区块链的同步和统一;
* 公开透明：每个节点都有一个数据库副本，数据可以任意查询;
* 无法篡改：每一区块都会记录前一区块的加密区块头信息，并实现追溯和验证，确保无法篡改;
* 存在分叉：这是由P2P网络等物理环境，以及软件开发实践过程决定的，人们无法根本性杜绝。

也正是因为这样的特点，区块链的概念才逐渐火爆起来。与加密货币的概念相比，区块链这个名字抛开了代币的概念，更加形象化、技术化、去政治化，更适合作为一门技术去研究、去推广。实践证明，区块链技术能实现一切中心化应用的场景，可以解决（或更好的解决）很多中心化应用无法解决的问题，比如分布式财务管理、分布式存储、知识产权保护、电子商务，乃至物联网，特别是对于金融业而言，资金清算、审计等等，成本会大幅度降低。亿书，就是利用它公开透明、可追溯的特点，与数字出版结合起来，实现自媒体和版权保护，彻底解决当前数字出版版权保护不力的顽疾。

#### 3.区块链开发应该解决的问题

明白区块链基本原理之后，就可以着手设计其基本功能了。从需求的角度说，设计中需要做到如下几点：

（1）加载区块链。确保本地区块链合法，未被篡改。

* 保存创世区块
* 加载本地区块
* 验证本地区块

（2）同步区块链。确保本地区块链为网络中完整区块链的一个副本。

（3）处理新区块。同步后，该节点就可以处理网络中的交易了。

* 处理区块头信息，并产生区块；
* 收集整理交易，写入（关联）区块；
* 把新产生的区块写入区块链；
* 解决区块链分叉。

下面，我们从数据库设计出发，认真讨论亿书区款链是如何运作的。

#### 4.亿书区块链数据库设计

亿书使用SQLite数据库，与区块链相关的数据库结构如图：

![blocks-database.png][]

blocks表是区块链，trs表是各种交易，forks_stat表代表分叉状态。从关联关系上看，blocks首先是一个自引用表，使用previousBlock关联；与trs是一对多的关系，一条记录关联多条交易；与forks_stat也是一对多的关系，意思是有分叉。

#### 5.亿书区块链实现

这里按照上面提到的开发区块链要解决的问题，逐一对照，查看亿书技术实现。

（1）保存创世区块

创世区块是硬编码到客户端程序里的，会在客户端运行的时候，直接写入数据库。这样做的好处是保证每个客户端都有一个安全、可信的区块链的根。

```
// modules/blocks.js
// 78行
function Blocks(cb, scope) {
	library = scope;
	// 80行
	genesisblock = library.genesisblock;
	self = this;
	self.__private = private;
	private.attachApi();

	// 85行
	private.saveGenesisBlock(function (err) {
		setImmediate(cb, err, self);
	});
}
```

这是`modules/blocks.js`模块的构造函数，在入口程序`app.js`运行的时候，直接创建该模块的实例，85行的代码`private.saveGenesisBlock`方法直接运行。如果已经运行过，该方法就会返回，什么都不做。如果第一次运行，该方法就会直接保存创世区块（80行的genesisblock），接着调用源文件266行的`private.saveBlock`方法（不再粘贴），把创世区块记录（包括交易）保存到数据库。

这是一个非常典型的区块创建过程，我们可以借机会看看一个区块（创世）的数据是什么样的：

```
// genesisBlock.json 文件
{
  "version": 0,

	// 3行
  "totalAmount": 10000000000000000,  
  "totalFee": 0,
  "reward": 0,
  "payloadHash": "1cedb278bd64b910c2d4b91339bc3747960b9e0acf4a7cda8ec217c558f429ad",
  "timestamp": 0,
  "numberOfTransactions": 103,
  "payloadLength": 20326,
  "previousBlock": null,
  "generatorPublicKey": "b7b46c08c24d0f91df5387f84b068ec67b8bfff8f7f4762631894fce4aff6c75",

	// 1757行
  "height": 1,
  "blockSignature": "2985d896becdb91c283cc2366c4a387a257b7d4751f995a81eae3aa705bc24fdb950c3afbed833e7d37a0a18074da461d68d74a3a223bc5f8e9c1fed2f3fec0e",
  "id": "8593810399212843182"，

	// 12行。为了方便阅读，这里把关联的交易信息排版在最后位置
	"transactions": [
    {
      "type": 0,

			// 15行
      "amount": 10000000000000000,
      "fee": 0,
      "timestamp": 0,
      "recipientId": "6722322622037743544L",
      "senderId": "5231662701023218905L",
      "senderPublicKey": "b7b46c08c24d0f91df5387f84b068ec67b8bfff8f7f4762631894fce4aff6c75",
      "signature": "aa413208c32d00b89895049ff21797048fa41c1b2ffc866900ffd97570f8d87e852c87074ed77c6b914f47449ba3f9d6dca99874d9f235ee4c1c83d1d81b6e07",
      "id": "5534571359943011068"
    },
		{
			"type": 2,
			"amount": 0,
			"fee": 0,
			"timestamp": 0,
			"recipientId": null,
			"senderId": "13689350125727268512L",
			"senderPublicKey": "8b3aa957ff8806a8f746acc579385fbf1296de9a604ac99917129f2faf937f1b",
			"asset": {
				"delegate": {
					"username": "genesisDelegate51"
				}
			},
			"signature": "d04ad75f229cbd93570612b7586ea5c13f44a26e9cfad7875580499bc9bac03811f1990cdf6a7b7f76cb1826473224334eabd3ac9b3ddcc39f3852e836956404",
			"id": "9198061231590533593"
		},

		...

		{
      "type": 3,
      "amount": 0,
      "fee": 0,
      "timestamp": 0,
      "recipientId": "6722322622037743544L",
      "senderId": "6722322622037743544L",
      "senderPublicKey": "3ed4d689ced148a97017e2f611b5c4aa28de1564a92fca8234d32290319dbdb3",
      "asset": {
        "votes": [
          "+3319e5bb7b26eda2f3ba91d55536e8260b58bb37b968233823c2ba588200459f",        
        ]
      },
      "signature": "96e1da0134268b02981292b1235dbc07c7dc0acdd348f15a89bc0617bc1361023a8445414843e54d429fa3380f46da9063ed0f4f549e39ae79efef5262301b00",
      "id": "10175549538740098435"
    }
    ...
  ]
}
```

这些字段，我们在上面的数据库表里已经列出，下面看看几个关键数据：

3行：在创世区块设定初始代币总量，这里是1亿;
1757行：创世区块高度为1;
12行：区块必须包含交易，这里是3种类型的交易，之前分析过，它们分别是转账交易、受托人交易和投票交易。第1个转账交易，把初始区块的代币全部转到了另一个账户，这在实际的生产环境，特别是在ICO（预售）之后，可以直接转给参与众筹的实际用户。所以，创世区块有其非常实际的意义。其它两种交易，是支撑亿书共识机制的。

（2）加载本地区块

任何节点，都需要先验证本地区块链，确保本地区块链没有被篡改，然后才可以同步缺失的其他节点的区块。这里的加载过程是为后面的验证作准备的，毕竟需要遍历每一个区块，然后才能逐一验证。这个加载过程与软件启动相关，是软件初始化过程中的一部分，开发中不需要与网络节点联网等其他问题纠缠在一起。因此，代码需要被放在入口文件中去执行。我们在《入口程序app.js解读》一章里解读了app.js文件，但是并不详细，仅仅梳理了程序的大致流程。这里重新提及，专注于区块链加载验证的问题，这在具体开发过程中，是很正常的增量开发的思路。

```
// app.js文件
...
ready: ['modules', 'bus', function (cb, scope) {
	// 435行
	scope.bus.message("bind", scope.modules);
	cb();
}]
```

app.js文件 435行: 触发了的“bind”事件（这是自定义的事件处理机制，请参考开发实践中关于事件循环的部分章节），会执行所有模块里的“onBind()”方法。该方法运行之前，各个模块仅仅被实例化，处于待命状态，所以“bind”事件是激活各模块的重要事件，是继各模块构造函数运行之后的关键方法（具体流程，请参考本部分第一章，模块的加载流程图）。大部分模块里的“onBind()”方法仅仅用来初始化某个变量，唯独`loader.js`模块，执行了下面的代码：

```
// modules/loader.js文件
Loader.prototype.onBind = function (scope) {
	modules = scope;
	// 534行
	private.loadBlockChain();
};
```

modules/loader.js文件 534行： `private.loadBlockChain` 方法就是用来加载区块链的，内容如下：

```
// modules/loader.js文件
private.loadBlockChain = function () {
	var offset = 0, limit = library.config.loading.loadPerIteration;
	var verify = library.config.loading.verifyOnLoading;

	// 357行，闭包
	function load(count) {
		verify = true;
		private.total = count;

		library.logic.account.removeTables(function (err) {
			if (err) {
				throw err;
			} else {
				library.logic.account.createTables(function (err) {
					if (err) {
						throw err;
					} else {
						// 369行
						async.until(
							function () {
								return count < offset;
							}, function (cb) {
								library.logger.info('Current ' + offset);
								setImmediate(function () {
									modules.blocks.loadBlocksOffset(limit, offset, verify, function (err, lastBlockOffset) {
										if (err) {
											return cb(err);
										}
										// 380行
										offset = offset + limit;
										private.loadingLastBlock = lastBlockOffset;

										cb();
									});
								});
							}, function (err) {
								  ...
									// 398行
									library.logger.info('Blockchain ready');
									library.bus.message('blockchainReady');
								}
							}
					...
	}

	// 408行
	library.logic.account.createTables(function (err) {
		if (err) {
			throw err;
		} else {
			library.dbLite.query("select count(*) from mem_accounts where blockId = (select id from blocks where numberOfTransactions > 0 order by height desc limit 1)", {'count': Number}, function (err, rows) {
				...
				var reject = !(rows[0].count);

				modules.blocks.count(function (err, count) {
					...
					if (reject || verify || count == 1) {
						// 428行
						load(count);
					} else {
						// 其他情况，请查看源码
						...
};
```

408行：将调用logic/account.js的createTables()方法，创建与用户相关的帐号信息表，全部以“mem_”开头，主要包括“mem_accounts”，“mem_accounts2contacts”，“mem_accounts2u_contacts”，“mem_accounts2delegates”，“mem_accounts2u_delegates”，“mem_accounts2multisignatures”，“mem_accounts2u_multisignatures”，“mem_round”等7个表。这些信息与用户相关，不需要被其他节点同步，因此在同步时创建。这与本部分第一篇里列出的表格不同，那些表格是需要同步处理的。

如果是新客户端，数据库为初始创建，创世区块第一次写入，count == 1，会立刻调用闭包load()函数（428行），加载验证缺失的区块。我们先不考虑其他情况，直接看357行的load()函数，可以发现该函数先删除帐号表格（removeTables），然后重建（createTables），并通过“async.until”方法（369行）进行循环加载区块链数据，具体方法是 modules/blocks.js的loadBlocksOffset()。当 count < offset 返回 “true” 的时候，循环结束，区块链数据同步完毕，然后触发 “blockchainReady” 事件（398行）。

这里的 “Offset” 不是分页数据，而是一次加载的区块数量，这样做的好处是避免一次性加载全部区块链，导致数据请求量过大，影响计算机性能。这个值最大是 limit 的值（380行），limit 等于 “config.json” 文件设定的全局变量 loading.loadPerIteration。用户可以修改该配置文件，在启动软件时通过命令行参数“-c”选择自己的配置文件，从而实现定制。如下：

```  
// config.json文件
// 132行
"loading": {
    "verifyOnLoading": false,
    "loadPerIteration": 5000
}
```

（3）验证本地区块

上面说到 modules/blocks.js 的 loadBlocksOffset() 方法才是处理加载的具体方法，也是验证的方法所在。

```
// modules/blocks.js文件
Blocks.prototype.loadBlocksOffset = function (limit, offset, verify, cb) {
	...
	library.dbSequence.add(function (cb) {
		library.dbLite.query("SELECT " +
			...		
			async.eachSeries(blocks, function (block, cb) {
				async.series([
					function (cb) {
						if (block.id != genesisblock.block.id) {
							if (verify) {
								// 627行 追溯区块
								if (block.previousBlock != private.lastBlock.id) {
									return cb({
										message: "Can't verify previous block",
										block: block
									});
								}

								try {
									// 635行 验证块签名
									var valid = library.logic.block.verifySignature(block);
								}
								...
								if (!valid) {									
									return cb({
										message: "Can't verify signature",
										block: block
									});
								}
								// 650行 验证块时段（Slot）
								modules.delegates.validateBlockSlot(block, function (err) {
								...
					}, function (cb) {
						// 先给交易排序，让投票或签名交易排在前面
						...
						async.eachSeries(block.transactions, function (transaction, cb) {
							if (verify) {
								modules.accounts.setAccountAndGet({publicKey: transaction.senderPublicKey}, function (err, sender) {
									...
									if (verify && block.id != genesisblock.block.id) {
										// 690行 验证交易
										library.logic.transaction.verify(transaction, sender, function (err) {
										...											
								});
							} else {
								setImmediate(cb);
							}
						}, function (err) {
							if (err) {
								// 如果出现错误，要回滚
								async.eachSeries(transactions.reverse(), function (transaction, cb) {
									async.series([
										function (cb) {
											modules.accounts.getAccount({publicKey: transaction.senderPublicKey}, function (err, sender) {
												...
												modules.transactions.undo(transaction, block, sender, cb);
											});
										}, function (cb) {
											modules.transactions.undoUnconfirmed(transaction, cb);
										}
									  ...						
};
```

逐个加载区块，并验证：
627行：追溯前一区块，无法追溯自然是不正确的。
635行：验证块签名，防止块内容被篡改。建议认真阅读该行调用的签名验证方法“verifySignature()”（在“logic/block.js”文件的150行，请去源码库查看），这应该是对二进制数据（这里是区块数据）进行签名验证的典型用法。验证失败，就要终止整个循环，删除该块及其以后的块。
650行：验证块时段（Slot），防止块位置被篡改。实际上是变相验证了区块的高度及其时间戳（相关技术请看开发实践部分《关于时间戳及相关问题》的讨论）。亿书网络按照一定的周期循环（具体请参看《DPOS机制》），每一个块都可以根据其高度计算出它的出块时段，这与它的时间戳是对应的，这就锁定了区块位置，不然就是有问题。为什么要选择验证块时段，而不是简单直接的高度或时间戳？这是因为区块链有分叉的情况，相同高度存在多个块和时间戳，但相同的块时段却只能是一个。
690行：验证交易。具体流程请参考《交易》一章的相关内容。

（4）同步区块链

我们上面说了，当加载验证本地区块结束，程序触发了“blockchainReady”事件（modules/loader.js 398行），于是各个模块里对应的“onBlockchainReady()”方法被执行。如果，查看每个模块对应的“onBlockchainReady()”方法，我们就能很轻松地了解，接下来程序在做什么。

这里，我们要考察如何从其他节点同步区块链，自然要看看节点模块里对应的方法。我们在《一个精巧的P2P网络实现》一章，已经贴出了“onBlockchainReady()”方法的代码，这里不再重复，请看对应源码的364行。该行是在更新了节点之后，调用了“library.bus.message('peerReady')”方法，触发了另一个“peerReady”事件。这才是我们最想要的，再次回到modules/loader.js文件，该文件也定义了“peerReady”事件，如下：

```
// modules/loader.js
// 492行
Loader.prototype.onPeerReady = function () {
	setImmediate(function nextLoadBlock() {
		...
			// 499行
			private.loadBlocks(lastBlock, cb);
		...
	});

	setImmediate(function nextLoadUnconfirmedTransactions() {
		...
		// 514行
		private.loadUnconfirmedTransactions(function (err) {
		...

	});

	setImmediate(function nextLoadSignatures() {
		...
		// 523行
		private.loadSignatures(function (err) {
		...
	});
};
```

该事件方法，通过“private.loadBlocks()”等三个方法分别同步区块（499行）、未确认交易和签名。限于篇幅，我们仅分析“private.loadBlocks()”方法，其他两个逻辑，请自行查阅源码。

```
// modules/loader.js
// 225行
private.loadBlocks = function (lastBlock, cb) {
	// 226行
	modules.transport.getFromRandomPeer({
		api: '/height',
		method: 'GET'
	}, function (err, data) {
		var peerStr = data && data.peer ? ip.fromLong(data.peer.ip) + ":" + data.peer.port : 'unknown';
		...		
		if (bignum(modules.blocks.getLastBlock().height).lt(data.body.height)) {
			...
			if (lastBlock.id != private.genesisBlock.block.id) {
				// 259行
				private.findUpdate(lastBlock, data.peer, cb);
			} else { // Have to load full db
				// 261行
				private.loadFullDb(data.peer, cb);
			}
			...
	});
};
```

226行的“transport.getFromRandomPeer()”方法，已经在《一个精巧的P2P网络实现》一章分析过，这里不再赘述。该方法通过随机选择节点，并调用这里提供的api获得远程节点的“height”数据，在确保本地区块链高度小于远程节点区块链高度的前提下，如果本地是创世区块就把远程节点整个数据库同步过来，调用“private.loadFullDb()”方法，不然就调用“private.findUpdate()”方法更新缺失的区块。前者很简单，属于后者的特殊情况，仅仅分析后者即可，代码如下：

```
// modules/loader.js
// 75行
private.findUpdate = function (lastBlock, peer, cb) {
	...
	modules.blocks.getCommonBlock(peer, lastBlock.height, function (err, commonBlock) {
		...		
		var toRemove = lastBlock.height - commonBlock.height;

		if (toRemove > 1010) {
			library.logger.log("long fork, ban 60 min", peerStr);
			modules.peer.state(peer.ip, peer.port, 0, 3600);
			return cb();
		}

		var overTransactionList = [];
		modules.transactions.undoUnconfirmedList(function (err, unconfirmedList) {
			...
			for (var i = 0; i < unconfirmedList.length; i++) {
				var transaction = modules.transactions.getUnconfirmedTransaction(unconfirmedList[i]);
				overTransactionList.push(transaction);
				modules.transactions.removeUnconfirmedTransaction(unconfirmedList[i]);
			}

			async.series([
				function (cb) {
					if (commonBlock.id != lastBlock.id) {
						modules.round.directionSwap('backward', lastBlock, cb);
					} else {
						cb();
					}
				},
				function (cb) {
					library.bus.message('deleteBlocksBefore', commonBlock);

					modules.blocks.deleteBlocksBefore(commonBlock, cb);
				},
				function (cb) {
					if (commonBlock.id != lastBlock.id) {
						modules.round.directionSwap('forward', lastBlock, cb);
					} else {
						cb();
					}
				},
				function (cb) {
					library.logger.debug("Loading blocks from peer " + peerStr);

					modules.blocks.loadBlocksFromPeer(peer, commonBlock.id, function (err, lastValidBlock) {
						if (err) {
							modules.transactions.deleteHiddenTransaction();
							library.logger.error(err);
							library.logger.log("Failed to load blocks, ban 60 min", peerStr);
							modules.peer.state(peer.ip, peer.port, 0, 3600);

							if (lastValidBlock) {
								var uploaded = lastValidBlock.height - commonBlock.height;

								if (toRemove < uploaded) {
									library.logger.info("Remove blocks again until " + lastValidBlock.id + " (at " + lastValidBlock.height + ")");

									async.series([
										function (cb) {
											if (lastValidBlock.id != lastBlock.id) {
												modules.round.directionSwap('backward', lastBlock, cb);
											} else {
												cb();
											}
										},
										function (cb) {
											modules.blocks.deleteBlocksBefore(lastValidBlock, function (err) {
												async.series([
													function (cb) {
														if (lastValidBlock.id != lastBlock.id) {
															modules.round.directionSwap('forward', lastBlock, cb);
														}
													},
													function (cb) {
														async.eachSeries(overTransactionList, function (trs, cb) {
															modules.transactions.processUnconfirmedTransaction(trs, false, cb);
														}, cb);
													}
												], cb);
											});
										}
									], cb);

								} else {
									library.logger.info("Remove blocks again until common " + commonBlock.id + " (at " + commonBlock.height + ")");

									async.series([
										function (cb) {
											if (commonBlock.id != lastBlock.id) {
												modules.round.directionSwap('backward', lastBlock, cb);
											} else {
												cb();
											}
										},
										function (cb) {
											modules.blocks.deleteBlocksBefore(commonBlock, cb);
										},
										function (cb) {
											if (commonBlock.id != lastBlock.id) {
												modules.round.directionSwap('forward', lastBlock, cb);
											} else {
												cb();
											}
										},
										function (cb) {
											async.eachSeries(overTransactionList, function (trs, cb) {
												modules.transactions.processUnconfirmedTransaction(trs, false, cb);
											}, cb);
										}
									], cb);
								}
							} else {
								async.eachSeries(overTransactionList, function (trs, cb) {
									modules.transactions.processUnconfirmedTransaction(trs, false, cb);
								}, cb);
							}
						} else {
							for (var i = 0; i < overTransactionList.length; i++) {
								modules.transactions.pushHiddenTransaction(overTransactionList[i]);
							}

							var trs = modules.transactions.shiftHiddenTransaction();
							async.whilst(
								function () {
									return trs;
								},
								function (next) {
									modules.transactions.processUnconfirmedTransaction(trs, true, function () {
										trs = modules.transactions.shiftHiddenTransaction();
										next();
									});
								}, cb);
						}
					});
				}
			], cb);
		});
	});
};
```

（5）创建新区块、解决分叉等问题

这些功能都是受托人处理的，所以还是放在《DPOS机制》一章去解析吧。

## 总结

本文从技术角度，描述了区块链的相关概念，并结合源码，解读了亿书区块链相关实现，这对于直观了解和学习区块链是有帮助的。特别是社区里，有些币圈网友认为压根就不应该有区块链分叉，本文的回答可能会让他们失望了，现实世界理想永远是遥不可及的事情，只有更好，没有完美。因此，包括区块链技术在内，只要是介入人类经济生态的应用，永远都不是单纯的技术性问题，它的更深层次的问题在于社区，以及基于人类经济生态的政治文化。

原本应该把全部关于区块链的分析都纳入本章内容，这样才算完整。但是，基于DPOS机制的应用，创建新区块和解决分叉等问题，都是受托人的事情，我们还是放在共识机制的分析解读里比较好，同时，也可以减少本文篇幅，让各章相对均匀。请看下一篇《DPOS机制》。

## 链接

**本系列文章即时更新，若要掌握最新内容，请关注下面的链接**

本源文地址： https://github.com/imfly/bitcoin-on-nodejs

亿书白皮书： http://ebookchain.org/ebookchain.pdf

亿书官网： http://ebookchain.org

亿书官方QQ群：185046161（亿书完全开源开放，欢迎各界小伙伴参与）

## 参考

[从数据库发展规律看区块链技术](http://chainb.com/?P=Cont&id=33)

[区块链](http://www.8btc.com/what-is-blockchain)

[关于比特币硬分叉和软分叉的争议](http://www.8btc.com/on-consensus-and-forks)

[以太坊软分叉失败，硬分叉成功](http://8btc.com/thread-36657-1-1.html)

[blocks-class.png]: ../styles/images/modules/blocks/blocks-class.png
[blocks-activity.png]: ../styles/images/modules/blocks/blocks-activity.png
[stack-drawers.png]: ../styles/images/third/drawers2.png
[blocks-database.png]: ../styles/images/modules/blocks/blocks-database.png
